 * revamp to support actual bufferpool and not just some beefed up systems project
 i.e.
   * perform file io on the user's thread
   * write page to disk, i.e. evict only if its log sequence number is greater than flushed log sequence number

 * Actual simple buffer pool
  * no page request struct all ->  threads perform their own IO
  * a valid page frame is unevictable if is_IO_op || readers_count || writers_count || readers_waiting || writers_waiting || upgraders_waiting
  * every get/release lock request check and operate on max frame count and the current frame count
  * wakeup respective threads readers or writers, after IO or after releasing a lock
  * set up a multi-threaded job that check if a page is flushable and flush it, a valid page is flushable if is_dirty && can_be_flushed && writers_count == 0
  * asynchornously bring a page with a page_id to bufferpool, and put it at the end of the buffer pool's lru, if it is already in the buffer pool then only bump it to the end of lru
  * asynchronously flush a page from the buffer pool
  * evict on non-dirty pages from the bufferpool, if there are no clean pages, then run a page flush mechanism, where all the dirty pages are check if they can be flushed to disk, if yes, these pages are given to threadpool to be written to disk, while we wait on a condition variable to become true. Once all pages are written, we call fsync and then clear dirty bits of all the pages, and wake up any thread that is waiting for the flush to be completed.
 * use a flag to suggest if flush is in progress, and a condition variable so other threads can wait on it.
 
 * WAL logger takes in following parameters
   read_blocks(void* dest, uint64_t block_id, uint64_t block_count, const void* context);
   write_blocks(const void* src, uint64_t block_id, uint64_t block_count, const void* context);
 * suggested api
   uint64_t write_log_record(const logger_handle* handle, const void* log_record, uint32_t log_record_size); // returns log sequence number
   uint64_t get_flushed_log_sequence_number(const logger_handle* handle); // latest log sequence number that has been flushed to disk
   uint64_t get_last_log_sequence_number(const logger_handle* handle);  // last log sequence number that been written, but it may not flushed to disk
   uint64_t flush_all_log_records(const logger_handle* handle); // returns flushed log sequence number, after flushing all the log records
 * now the log sequence number is the offset of the log record in context
 * each log record stores the size of the current log record (including the prefix mentioned here, hence it will always be non-zero) -> this allows going forward
 * each log file has a master record at offset 0, and size equal to the block size
 * each master record stores last_flushed_log_sequence_number
