 * revamp to support actual bufferpool and not just some beefed up systems project
 i.e.
   * perform file io on the user's thread
   * write page to disk, i.e. evict only if its log sequence number is greater than flushed log sequence number

 * Actual simple buffer pool
  * api to get page with read/write lock, release page with read/write lock
  * no page request struct all ->  threads perform their own IO
  * segregate file block io into a separate project name is BlockIO, this project can be used for both logger and buffer pool
  * page_descriptor will have following fields
    * page_id
    * frame -> actual memory
    * bits for
      * is_valid (has valid data for the corresponding page id on the frame)
      * is_being_written_to_disk (set if the page is only being flushed to disk)
      * is_being_read_from_disk (set if the page is under IO operation, read or write)
      * is_dirty (if new data has been written to it after its last read from disk)
    * readers/writers_count (no of threads/transaction currently reading/writing it)
    * readers waiting and conditional variable for readers to wait
    * writers waiting and conditional variable for writers to wait
    * upgraders waiting and conditional variable for upgraders to wait
  * a valid page frame is unevictable if is_IO_op || readers_count || writers_count || readers_waiting || writers_waiting || upgraders_waiting
  * there must me a provision to change frame count for the bufferpool, every get/release lock request check and operate on max frame count and the current frame count
  * wakeup respective threads readers or writers, after IO or after releasing a lock
  * a page descriptor must be searchable using both page_id and page_frame, using 2 hashtables
  * buffer pool is intialized with following parameters
    * frame_count
    * mutex* external_mutex (if provided all operation must be called with only external mutex locked, else if NULL, bufferpool uses its own internal global mutex for all operations)
    * read/write blockIO (taking frame*, page_id, context) function calls or wrappers to them -> this function can also be used to track recLSN's of dirty pages, by storing a hashmap of frame pointers to page_id, recLSNs
    * a function to check if the page can be flushed to disk, probably to evit it
  * get functions return NULL if the page is not present in bufferpool and no other page can be evicted
  * get functions return a flag that suggest if the current request brought the page into memory
  * get new page with write lock can also done
  * set up a multi-threaded job that check if a page is flushable and flush it, a valid page is flushable if is_dirty && can_be_flushed && writers_count == 0
