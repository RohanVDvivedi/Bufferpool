 * revamp to support actual bufferpool and not just some beefed up systems project
 i.e.
   * perform file io on the user's thread
   * write page to disk, i.e. evict only if its log sequence number is greater than flushed log sequence number

 * Actual simple buffer pool
  * api to get page with read/write lock, release page with read/write lock
  * no page request struct all ->  threads perform their own IO
  * segregate file block io into a separate project name is BlockIO, this project can be used for both logger and buffer pool
  * page_descriptor will have following fields
    * page_id
    * frame -> actual memory
    * bits for
      * is_valid (has valid data for the corresponding page id on the frame)
      * is_being_written_to_disk (set if the page is only being flushed to disk)
      * is_being_read_from_disk (set if the page is under IO operation, read or write)
      * is_dirty (if new data has been written to it after its last read from disk)
    * readers/writers_count (no of threads/transaction currently reading/writing it)
    * readers waiting and conditional variable for readers to wait
    * writers waiting and conditional variable for writers to wait
    * upgraders waiting and conditional variable for upgraders to wait
  * a valid page frame is unevictable if is_IO_op || readers_count || writers_count || readers_waiting || writers_waiting || upgraders_waiting
  * there must me a provision to change frame count for the bufferpool, every get/release lock request check and operate on max frame count and the current frame count
  * wakeup respective threads readers or writers, after IO or after releasing a lock
  * a page descriptor must be searchable using both page_id and page_frame, using 2 hashtables
  * buffer pool is intialized with following parameters
    * frame_count
    * mutex* external_mutex (if provided all operation must be called with only external mutex locked, else if NULL, bufferpool uses its own internal global mutex for all operations)
    * read/write page functions (taking frame*, page_id, page_size, context) function calls or wrappers to them -> this function can also be used to track recLSN's of dirty pages, by storing a hashmap of frame pointers to page_id, recLSNs
    read_page_to_persistent_memory(void* dest_frame, uint64_t page_id, uint64_t page_size, const void* context);
    write_page_to_persistent_memory(const void* src_frame, uint64_t page_id, uint64_t page_size, const void* context);
    * a function to check if the page can be flushed to disk, probably to evit it
  * get functions return NULL if the page is not present in bufferpool and no other page can be evicted
  * get functions return a flag that suggest if the current request brought the page into memory
  * get new page with write lock can also done
  * set up a multi-threaded job that check if a page is flushable and flush it, a valid page is flushable if is_dirty && can_be_flushed && writers_count == 0

 * BlockIO project alows you to read/write data from block device, with a predefined block size
  * suggested api
   open_block_file, close_block_file
   get_block_size();
   read_blocks (const block_io_handle* handle,      void* dest, uint64_t block_id, uint64_t block_count);
   write_blocks(const block_io_handle* handle, const void* src, uint64_t block_id, uint64_t block_count);

 * WAL logger takes in following parameters
   read_blocks(void* dest, uint64_t block_id, uint64_t block_count, const void* context);
   write_blocks(const void* src, uint64_t block_id, uint64_t block_count, const void* context);
 * suggested api
   uint64_t write_log_record(const logger_handle* handle, const void* log_record, uint32_t log_record_size); // returns log sequence number
   uint64_t get_flushed_log_sequence_number(const logger_handle* handle); // latest log sequence number that has been flushed to disk
   uint64_t get_last_log_sequence_number(const logger_handle* handle);  // last log sequence number that been written, but it may not flushed to disk
   uint64_t flush_all_log_records(const logger_handle* handle); // returns flushed log sequence number, after flushing all the log records
 * now the log sequence number is the offset of the log record in context
 * each log record stores the size of the current log record (including the prefix mentioned here, hence it will always be non-zero) -> this allows going forward
 * each log file has a master record at offset 0, and size equal to the block size
 * each master record stores last_flushed_log_sequence_number
