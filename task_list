 * implement a function notify_modification_for_write_locked_page(bufferpool* bf, void* frame);
   * this function may be called only if you have a write lock on the page, and the is_under_read_IO == 0 and is_under_write_IO == 0
   * this function will mark the page as dirty, if it wasn't already dirty
   * Add this comment: while you have a write lock on the page, after modifying a page, you must either call this function atleast once OR set the was_modified bit in the next function call that takes this flag.
 * Build a DiskPoolPager project, that manages a bitmap of the size of a page, while leaving some bytes for log_seq_nr, and that can allocate and free pages, and extend the api of the bufferpool through it.