 * revamp to support actual bufferpool and not just some beefed up systems project
 i.e.
   * perform file io on the user's thread
   * write page to disk, i.e. evict only if its log sequence number is greater than flushed log sequence number

 * Actual simple buffer pool
  * no page request struct all ->  threads perform their own IO
  * a valid page frame is unevictable if is_IO_op || readers_count || writers_count || readers_waiting || writers_waiting || upgraders_waiting
  * every get/release lock request check and operate on max frame count and the current frame count
  * wakeup respective threads readers or writers, after IO or after releasing a lock
  * set up a multi-threaded job that check if a page is flushable and flush it, a valid page is flushable if is_dirty && can_be_flushed && writers_count == 0
  * asynchornously bring a page with a page_id to bufferpool, and put it at the end of the buffer pool's lru, if it is already in the buffer pool then only bump it to the end of lru
  * asynchronously flush a page from the buffer pool
  * evict on non-dirty pages from the bufferpool, if there are no clean pages, then run a page flush mechanism, where all the dirty pages are check if they can be flushed to disk, if yes, these pages are given to threadpool to be written to disk, while we wait on a condition variable to become true. Once all pages are written, we call fsync and then clear dirty bits of all the pages, and wake up any thread that is waiting for the flush to be completed.
 * use a flag to suggest if flush is in progress, and a condition variable so other threads can wait on it.