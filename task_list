 * revamp to support actual bufferpool and not just some beefed up systems project
 i.e.
   * perform file io on the user's thread
   * write page to disk, i.e. evict only if its log sequence number is greater than flushed log sequence number

 * Actual simple buffer pool
  * api to get page with read/write lock, release page with read/write lock
  * no page request struct all threads perform their own IO
  * segregate file block io into a separate project name is BlockIO, this project can be used for both logger and buffer pool
  * page_descriptor will have following fields
    * page_id
    * frame -> actual memory
    * bits for
      * is_valid (has valid data for the corresponding page id on the frame)
      * is_IO_op (set if the page is under IO operation, read o write)
      * is_dirty (if new data has been written to it after its last read from disk)
    * readers/writers_count (no of threads/transaction currently reading/writing it)
    * readers waiting and conditional variable for readers to wait
    * writers waiting and conditional variable for writers to wait
    * upgraders waiting and conditional variable for upgraders to wait
  * a valid page frame is unevictable if is_IO_op || readers_count || writers_count || readers_waiting || writers_waiting || upgraders_waiting
  * there must me a provision to change frame count for the bufferpool, every get/release lock request check and operate on max frame count and the current frame count
  * a page descriptor must be searchable using both page_id and page_frame, using 2 hashtables
  * buffer pool is intialized with following parameters
    * frame_count
    * mutex* external_mutex (if provided all operation must be called with only external mutex locked, else if NULL, bufferpool uses its own internal global mutex for all operations)
    * read/write blockIO function call
    * get functions return NULL if the page is not present in bufferpool and no other page can be evicted
    * get new page with write lock can also done
